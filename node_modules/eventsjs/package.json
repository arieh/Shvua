{
  "name": "eventsjs",
  "version": "1.2.3",
  "description": "Event supplier library for browser and server",
  "main": "Events.js",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/arieh/Events.git"
  },
  "keywords": [
    "Events"
  ],
  "author": {
    "name": "arieh@glzr.co.il"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "2209fff02c05df1d5a07a0504183fb6ae92b903c",
  "readme": "#Events\n\n\nThis library is intended to supply an event interface to javascript objects using a Mixin pattern.\nThe library is designed with encapsulation and uninterupptability in mind. This means a broken function will not stop\nthe event loop (on modern browsers).\n\nEvents now also supports AMD and CommonJS syntax.\n\n##Features\n  1. Easy to integrate - can be used as a mixin, thus making it easy to integrate with any existing codebase.\n  2. Fast - On modern browsers (FF, Chrome, Safari and IE > 8) the library uses costume DOM events to handle the events.\n  3. Encapsulated - When used on modern browsers, broken functions will not break the event loop.\n  4. Supports creating pseudo events (like `:once` and `:latched`).\n  5. Comes with built in useful utilities.\n  6. Cross-browser - falls back to a more standard costume events handler.\n\n## Installation\n\n```\nnpm install arieh-events\n```\n\n##Usage\n\nThe simplest way to enable events support is like this:\n\n\n    function MyObject(){\n        Events.call(this);\n    }\n\n\nThis method will introduce the entire events API onto the object.\nYou could also create an instance of the object:\n\n\n    var ev = new Events();\n\n\nOr, if you wish, you could always inherit it:\n\n\n    obj.prototype = new Events();\n\n\n##Methods\n\n###addEvent(type, fn)\nAdds a listener. When fired, the function will be passed an event object, with 2 parameters:\n  1. args - arguments that were passed by dispatcher.\n  2. dispatcher - the object dispatching the event\n\n\n    obj.addEvent('show',function(e){\n        e.dispatcher; //obj\n        e.args; //whatever arguments were passed\n    });\n\n###addEvents(events)\nAdds multiple events in one callback\n\n    obj.addEvents({\n        'show' : show_fn,\n        'hide' : hide_fn\n    });\n\n###fireEvent(type, args)\nDispathces an event, passing arguments:\n\n    obj.fireEvent('show', {counter:1});\n\n###removeEvent(type, fn)\nRemoves a listener.\n\n    obj.removeEvent('show', this.bound.handleShow);\n\n###addEventOnce(type, fn)\nSame as `addEvent` only it will remove the listener automatically once dispatched.\n\n##Pseudo events\nThe library supports a few pseudo events out of the box:\n\n  1. `:once` - when used event will be added once.\n  2. `:latched` - see latched section\n  3. `:times(number)` - same as once, only it will execute X times (as passed by parameter).\n  4. `:delay(ms)` - on `fireEvent`, will delay X miliseconds before firing the event. On `addEvent` will delay each execution of specific function.\n\n\n    obj.addEvent('test:once', function(){/* ... */ }); //will add a function to be fired once\n\n    obj.fireEvent('load:latched'); //will fire a latched event\n\n    obj.addEvent('test:times(5)', fn); //will add an event that will remove itself after 5 runs\n\n    obj.addEvent('test:delay(500)',fn); //will add an event that will wait 500ms before executing when fired\n\n    obj.fireEvent('test:delay(500)',args); //will wait 500ms before firing the event\n\n\nYou can also add your own pseudo events, by adding them to Events.Pseudoes.\nIn order to create a new pseudo-event, add an object to the collection, containing either `addEvent` method, `fireEvent` method or both.\nYou can even add a parameter to the pseudo-event.\nThe `addEvent` and `fireEvent` methods will be fired *instead* of the default methods. It's arguments will be the same as their default, with a third argument, which is the passed pseudo-parameter (if any).\nIn order to see more simply look at the code.\n\n\n###Important note\nThe library *does not support multiple pseudo events*. This is by design - the pseudo events hide complex logic and function-wrapping.\nDoing `addEvent:once:delay(1000)` might look nice, but hides the fact that it uses 3 levels of function wrapping.\nBy default, The library would simply fail to assign the pseudo event properly (will try to match `once:delay` which doesn't exist), and will log an error to the console.\nHowever, you can make the librart throw exceptions for multiple pseudo events by setting the `Events.strict` flag to true.\n\n##Latched events\nLatched events are events that once fired once will dispatch automatically afterwards. Examples for such events can be\na 'load' event, or a 'domready' event. If any arguments were passed, they will be passed on as well. For example:\n\n    obj.fireEvent('load:latched',{someParam:\"a\"});\n\n    //will be fire automatically\n    obj.addEvent('load', function(e){\n        e.args.someParam; //a\n    });\n\n\n##Cleanup\nIn case you want to ensure cleanup, the Mixin automatically listens to the `destroy` event and cleans itself up for destruction\n",
  "_id": "eventsjs@1.2.3",
  "dist": {
    "shasum": "29ac3ce9fad66cda5721636a9a2fd079ca4a306e"
  },
  "_from": "eventsjs@1.2.3",
  "_resolved": "https://registry.npmjs.org/eventsjs/-/eventsjs-1.2.3.tgz"
}
